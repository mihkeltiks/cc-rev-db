package main

//lint:file-ignore U1000 ignore unused helpers

import (
	"bytes"
	"debug/dwarf"
	"debug/elf"
	"fmt"
	"io"

	"github.com/go-delve/delve/pkg/dwarf/op"
	Logger "github.com/ottmartens/cc-rev-db/logger"
)

type dwarfData struct {
	modules []*dwarfModule
}
type dwarfModule struct {
	name         string           // name of the module
	startAddress uint64           // the start of the address range in the module
	endAddress   uint64           // the end of the address range in the module
	entries      []dwarfEntry     // entries in this module
	files        map[int]string   // source files of this module
	functions    []*dwarfFunc     // functions declared in this module
	variables    []*dwarfVariable // variables declared in this module
}

type dwarfEntry struct {
	// Program-counter value of a machine instruction
	// generated by the compiler. This entry applies to
	// each instruction from pc to just before the pc of the next entry.
	address uint64

	// key of the file in files map
	file int
	line int
	col  int

	// Address is one (of possibly many) PCs where execution should be
	// suspended for a breakpoint on exit from this function.
	prologueEnd bool

	// Address is one (of possibly many) PCs where execution should be
	// suspended for a breakpoint on exit from this function.
	epilogueBegin bool

	// Address is a recommended breakpoint location, such as the
	// beginning of a line, statement, or a distinct subpart of a statement.
	isStmt bool
}

func (de dwarfEntry) String() string {
	return fmt.Sprintf("entry{address: %x, line: %d, isStmt: %v}", de.address, de.line, de.isStmt)
}

type dwarfFunc struct {
	name   string // function name
	file   int    // file the function is declared at
	line   int64  // line nr
	col    int64  // col nr
	lowPC  uint64 // first PC address for the function
	highPC uint64 // last PC address for the function
}

type dwarfBaseType struct {
	name     string
	byteSize int64
	encoding string
}

type dwarfVariable struct {
	name                 string         // variable name
	baseType             *dwarfBaseType // type of the variable
	locationInstructions []byte         // raw dwarf location instructions
	function             *dwarfFunc     // the function where variable is declared (might be nil)
}

func (v *dwarfVariable) locationString() string {
	buf := new(bytes.Buffer)
	op.PrettyPrint(buf, v.locationInstructions)
	return buf.String()
}

func (v *dwarfVariable) String() string {
	return fmt.Sprintf("{name:%v, type: %v, location: %v}", v.name, v.baseType.name, v.locationString())
}

func (v *dwarfVariable) locationDecoded() (address uint64, pieces []op.Piece, err error) {
	addr, pieces, err := op.ExecuteStackProgram(op.DwarfRegisters{}, v.locationInstructions, 8, nil)
	return uint64(addr), pieces, err
}

func (m *dwarfModule) lookupFunc(functionName string) *dwarfFunc {
	for _, function := range m.functions {
		if function.name == functionName {
			return function
		}
	}
	return nil
}

func (d *dwarfData) lookupFunc(functionName string) (module *dwarfModule, function *dwarfFunc) {
	for _, module := range d.modules {
		if function := module.lookupFunc(functionName); function != nil {
			return module, function
		}
	}
	return nil, nil
}

func (d *dwarfData) lookupVariable(varName string) *dwarfVariable {
	for _, module := range d.modules {
		for _, variable := range module.variables {
			if variable.name == varName {
				return variable
			}
		}
	}

	return nil
}

func (d *dwarfData) lineToPC(file string, line int) (address uint64, err error) {

	for _, module := range d.modules {
		for _, moduleFile := range module.files {
			// correct module (this could be simplified by refactoring dwarfData)
			if moduleFile == file {
				for _, entry := range module.entries {

					if entry.line == line && entry.isStmt {
						Logger.Info("found suitable breakpoint: %v", entry)
						Logger.Info("file sanity check: %v\n", module.files[entry.file] == file)

						return entry.address, nil
					} else if entry.line == line {
						fmt.Printf("found non-stmt breakpoint at desired line: %v\n", entry)
					}
				}
			}
		}
	}

	return 0, fmt.Errorf("unable to find suitable instruction for line %d in file %s", line, file)
}

func (d *dwarfData) PCToLine(pc uint64) (line int, file string, functionName string, err error) {
	for _, module := range d.modules {
		if pc >= module.startAddress && pc <= module.endAddress {
			for _, entry := range module.entries {
				if entry.address == pc {
					// fmt.Printf("found entry with address-1 though: %v\n", entry)
					return entry.line, module.files[entry.file], "", nil
				}
			}
		}
	}
	return 0, "", "", fmt.Errorf("unable to find instruction matching address %v", pc)
}

func getDwarfData(targetFile string) *dwarfData {

	data := &dwarfData{
		modules: make([]*dwarfModule, 0),
	}
	var currentModule *dwarfModule
	var currentFunction *dwarfFunc

	baseTypeMap := make(map[uint32]*dwarfBaseType)

	elfFile, err := elf.Open(targetFile)
	if err != nil {
		panic(err)
	}
	dwarfRawData, err := elfFile.DWARF()
	if err != nil {
		panic(err)
	}

	reader := dwarfRawData.Reader()

	for {
		entry, err := reader.Next()

		if err == io.EOF || entry == nil {
			break
		}
		if err != nil {
			panic(err)
		}

		// base type declaration
		if entry.Tag == dwarf.TagBaseType {
			baseTypeMap[uint32(entry.Offset)] = &dwarfBaseType{
				name:     entry.Val(dwarf.AttrName).(string),
				byteSize: entry.Val(dwarf.AttrByteSize).(int64),
			}
		}

		// entering a new module
		if entry.Tag == dwarf.TagCompileUnit {
			currentModule = parseModule(entry, dwarfRawData)

			data.modules = append(data.modules, currentModule)

			currentFunction = nil
		}

		// function declaration
		if entry.Tag == dwarf.TagSubprogram {
			currentFunction = parseFunction(entry, dwarfRawData)

			currentModule.functions = append(currentModule.functions, currentFunction)
		}

		// variable declaration
		if entry.Tag == dwarf.TagVariable {
			variable := &dwarfVariable{
				name:                 entry.Val(dwarf.AttrName).(string),
				locationInstructions: entry.Val(dwarf.AttrLocation).([]byte),
				baseType:             baseTypeMap[uint32(entry.Val(dwarf.AttrType).(dwarf.Offset))],
				function:             currentFunction,
			}
			currentModule.variables = append(currentModule.variables, variable)
		}
	}

	return data
}

func parseFunction(entry *dwarf.Entry, dwarfRawData *dwarf.Data) *dwarfFunc {
	function := dwarfFunc{}

	for _, field := range entry.Field {
		switch field.Attr {
		case dwarf.AttrName:
			function.name = field.Val.(string)
		case dwarf.AttrDeclFile:
			function.file = int(field.Val.(int64))
		case dwarf.AttrDeclLine:
			function.line = field.Val.(int64)
		case dwarf.AttrDeclColumn:
			function.col = field.Val.(int64)
		}
	}

	ranges, err := dwarfRawData.Ranges(entry)
	if err != nil {
		panic(err)
	}
	function.lowPC = ranges[0][0]
	function.highPC = ranges[0][1]

	return &function
}

func parseModule(entry *dwarf.Entry, dwarfRawData *dwarf.Data) *dwarfModule {
	module := dwarfModule{
		files:     make(map[int]string),
		functions: make([]*dwarfFunc, 0),
		variables: make([]*dwarfVariable, 0),
	}

	for _, field := range entry.Field {
		switch field.Attr {
		case dwarf.AttrName:
			module.name = field.Val.(string)
		case dwarf.AttrLanguage:
			// language can be inferred from the cu attributes. 22-golang, 12-clang
			// if field.Val.(int64) == 22 {
			// 	data.lang = golang
			// }
		}
	}

	ranges, err := dwarfRawData.Ranges(entry)

	if err != nil {
		panic(err)
	}
	// might be more than 1 range entry in theory
	module.startAddress = ranges[0][0]
	module.endAddress = ranges[0][1]

	lineReader, err := dwarfRawData.LineReader(entry)
	if err != nil {
		panic(err)
	}

	moduleFileIndexMap := make(map[string]int)

	files := lineReader.Files()
	for fileIndex, file := range files {
		if file != nil {
			module.files[fileIndex] = file.Name
			moduleFileIndexMap[file.Name] = fileIndex
		}
	}

	dEntries := make([]dwarfEntry, 0)
	for {
		var le dwarf.LineEntry

		err := lineReader.Next(&le)

		if err == io.EOF {
			break
		}

		entry := dwarfEntry{
			address:       le.Address,
			file:          moduleFileIndexMap[le.File.Name],
			line:          le.Line,
			col:           le.Column,
			prologueEnd:   le.PrologueEnd,
			epilogueBegin: le.EpilogueBegin,
			isStmt:        le.IsStmt,
		}

		dEntries = append(dEntries, entry)

	}

	module.entries = dEntries

	return &module
}
